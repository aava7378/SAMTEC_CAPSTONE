/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// 0: motor driver code with pid and pwm
// 1: nothing
// 3: Drive current, duty cycle, and frequency
// 4: IR sesnor code
// 5: New updated pid code to start heating peltier module and stop at a setpoint
// 8: volatge reading added

#define PI_LOOP 7
#define BANG_LOOP 12
#define MENU_OPTION 1
#define PI 45
#define MENU_N_8 20

#define MAIN MENU_N_8


#if (MAIN == UART_TEST)
#include "stm32f1xx.h"

#include "stm32f1xx.h"
static void delay(volatile uint32_t n) { while (n--) __NOP(); }

int main(void)
{
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;

    // PA2 output push-pull, 2 MHz
    GPIOA->CRL &= ~(0xFU << (2U * 4U));
    GPIOA->CRL |=  (0x2U << (2U * 4U));

    while (1) {
        GPIOA->ODR ^= (1U << 2);
        delay(800000);
    }
}


#endif


#if (MAIN == PI)

#include <stdint.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#include "rcc.h"
#include "delay.h"
#include "usart.h"

// If your project doesn't define this elsewhere:
#ifndef SYSCLK_FREQ_HZ
#define SYSCLK_FREQ_HZ 72000000UL
#endif

// -------- helpers --------
static void uart_puts(const char *s) { usart2_write_str(s); }

static int uart_try_getc(char *out)
{
#if defined(USART2)
    if (USART2->SR & (1U << 5)) {               // RXNE
        *out = (char)(USART2->DR & 0xFF);       // reading DR clears RXNE
        return 1;
    }
#endif
    return 0;
}

// Read a line with echo, polled:
// - call repeatedly, returns 1 when a full line is ready
static int uart_readline_poll(char *buf, uint32_t buf_sz)
{
    static uint32_t len = 0;
    char c;
    if (!uart_try_getc(&c)) return 0;

    // echo typed character back
    usart2_write_char(c);

    if (c == '\r' || c == '\n') {
        uart_puts("\r\n");
        buf[len] = '\0';
        len = 0;
        return 1;
    }

    // backspace support
    if (c == '\b' || c == 127) {
        if (len > 0) {
            len--;
            uart_puts("\b \b");
        }
        return 0;
    }

    // ignore other control chars
    if ((unsigned char)c < 32) return 0;

    if (len < (buf_sz - 1)) {
        buf[len++] = c;
    }
    return 0;
}

static void to_upper_inplace(char *s)
{
    for (; *s; ++s) *s = (char)toupper((unsigned char)*s);
}

// -------- main --------
int main(void)
{
    clock_init();
    systick_init(SYSCLK_FREQ_HZ);

    // IMPORTANT: this PCLK value must match your usart2_init() implementation.
    // On STM32F103 with SYSCLK=72MHz and APB1 prescaler /2, PCLK1 = 36MHz (common).
    usart2_init(8000000UL, 115200);

    uart_puts("\r\n[UART2 PI TEST - BARE METAL]\r\n");
    uart_puts("Type: PING or HELP\r\n");

    char line[96];

    uint32_t alive_ms = 0;

    while (1)
    {
//        // Periodic TX spam so you cannot "miss" boot prints
//        // (Assumes delay_ms works from systick)
//        if (alive_ms >= 1000) {
//            alive_ms = 0;
//            uart_puts("STM32_ALIVE\r\n");
//        }
//
//        // Handle incoming line
//        if (uart_readline_poll(line, sizeof(line))) {
//            // Normalize whitespace: just parse first token
//            char *cmd = strtok(line, " ");
//            if (!cmd) continue;
//
//            to_upper_inplace(cmd);
//
//            if (strcmp(cmd, "PING") == 0) {
//                uart_puts("PONG\r\n");
//            } else if (strcmp(cmd, "HELP") == 0) {
//                uart_puts("Commands: PING, HELP\r\n");
//            } else {
//                uart_puts("ERR\r\n");
//            }
//        }
//
//        delay_ms(10);
//        alive_ms += 10;

    	usart2_write_str("STM32_ALIVE\r\n");
    	    delay_ms(1000);
    }
}

#endif


#if (MAIN == MENU_OPTION)

#include <stdint.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>   // sscanf
#include <stdlib.h>  // strtof

#include "board.h"
#include "rcc.h"
#include "delay.h"
#include "usart.h"

#include "thermocouple.h"
#include "pwm.h"
#include "i2c.h"
#include "mlx90614.h"
#include "pid.h"
#include "adc.h"


// ------------ ADC / voltage sensing config ------------
#define PELTIER_ADC_CH   4U      // PA4 / ADC2_IN4
#define VREF_mV          3300U
// ------------------------------------------------------


// ----------------- UART print helpers -----------------
static void print_int(int v)
{
    char buf[16];
    int i = 15;
    buf[i] = '\0';
    int neg = (v < 0);
    if (neg) v = -v;

    do {
        buf[--i] = (char)('0' + (v % 10));
        v /= 10;
    } while (v);

    if (neg) buf[--i] = '-';
    usart2_write_str(&buf[i]);
}

static void print_float_1dp(float x)
{
    int32_t xi = (int32_t)x;
    int32_t xf = (int32_t)((x - (float)xi) * (x >= 0 ? 10.0f : -10.0f));

    if (x < 0 && xi == 0)
        usart2_write_char('-');

    print_int((int)xi);
    usart2_write_char('.');

    if (xf < 0) xf = -xf;
    print_int((int)xf);
}

static const char* mode_to_str(int mode)
{
    switch (mode) {
        case 0: return "HEATING_UP";
        case 1: return "IN_RANGE";
        case 2: return "STOPPED_OVER_TEMP_COOLING_DOWN";
        default: return "UNKNOWN";
    }
}
// ------------------------------------------------------


// ======================================================
// UART RX helpers
// ======================================================

static int usart2_try_read_char(char *out)
{
#if defined(USART2)
    if (USART2->SR & (1U << 5)) {          // RXNE
        *out = (char)(USART2->DR & 0xFF);  // read clears RXNE
        return 1;
    }
    return 0;
#else
    (void)out;
    return 0;
#endif
}

static int parse_float_line(const char *s, float *out)
{
    while (*s && isspace((unsigned char)*s)) s++;
    if (*s == '\0') return 0;

    char *endp = NULL;
    float v = strtof(s, &endp);
    if (endp == s) return 0;

    while (*endp && isspace((unsigned char)*endp)) endp++;
    if (*endp != '\0') return 0;

    *out = v;
    return 1;
}

static void print_settings(float setC, float ub, float lb)
{
    usart2_write_str("Target=");
    print_float_1dp(setC);
    usart2_write_str("C  UB=");
    print_float_1dp(ub);
    usart2_write_str("C  LB=");
    print_float_1dp(lb);
    usart2_write_str("C\r\n");
}

static void print_menu(void)
{
    usart2_write_str("\r\n=== MENU ===\r\n");
    usart2_write_str("1) Start/Resume streaming (20ms)\r\n");
    usart2_write_str("2) Stop heating + change setpoints (keeps TC monitoring)\r\n");
    usart2_write_str("3) HALT heating (keeps TC monitoring)\r\n");
    usart2_write_str("============\r\n");
}

// Read menu keys without blocking; echoes the key for UX
static int ui_poll_menu_key_nonblocking(char *key_out)
{
    char c;
    if (!usart2_try_read_char(&c)) return 0;

    // Echo the key
    usart2_write_char(c);
    if (c == '\r' || c == '\n') usart2_write_str("\r\n");

    *key_out = c;
    return 1;
}


// ======================================================
// Thermocouple watchdog tick (runs even in CONFIG/HALT)
// ======================================================

typedef struct {
    uint32_t ms_accum;     // for periodic prints
    uint32_t ms_print;     // print interval in ms
} tc_watchdog_t;

// Called periodically (e.g., every 20ms) to keep reading TC and optionally print.
static float tc_watchdog_tick(tc_watchdog_t *wd,
                              uint32_t dt_ms,
                              int print_enable,
                              const char *tag,
                              float ubC)
{
    wd->ms_accum += dt_ms;

    int32_t t_x10 = tc_read_c_x10();
    float measC = (float)t_x10 * 0.1f;

    if (print_enable && wd->ms_accum >= wd->ms_print) {
        wd->ms_accum = 0;

        // usart2_write_str(tag);
        // usart2_write_str(" TC=");
        // print_float_1dp(measC);
        // usart2_write_str("C");

        if (measC > ubC) {
            usart2_write_str("  (ABOVE_UB!)");
        }

        usart2_write_str("\r\n");
    }

    return measC;
}


static void uart_read_line_echo(char *buf, uint32_t buf_sz)
{
    uint32_t len = 0;

    while (1) {
        char c;

        // blocking wait
        while (!usart2_try_read_char(&c)) {
            // spin, no sampling, no background tasks
        }

        if (c == '\r' || c == '\n') {
            usart2_write_str("\r\n");
            break;
        }

        if (c == '\b' || c == 127) {
            if (len > 0) {
                len--;
                usart2_write_str("\b \b");
            }
            continue;
        }

        if ((unsigned char)c < 32) {
            continue;
        }

        if (len < (buf_sz - 1)) {
            buf[len++] = c;
            usart2_write_char(c);   // echo
        }
    }

    buf[len] = '\0';
}



// ======================================================
// UI State machine
// ======================================================
typedef enum {
    UI_STREAM = 0,
    UI_CONFIG = 1,
    UI_HALT   = 2
} ui_mode_t;


static void run_config_dialog(float *p_target,
                              float *p_ub,
                              float *p_lb,
                              pid_t *pid)
{
    char line[64];
    float v;

    usart2_write_str("\r\n--- CONFIG MODE ---\r\n");
    usart2_write_str("Heating OFF. Enter values in degC.\r\n");

    // Target
    while (1) {
        usart2_write_str("Temperature Target setpoint = ");
        uart_read_line_echo(line, sizeof(line));
        if (parse_float_line(line, &v)) {
            *p_target = v;
            pid->integrator  = 0.0f;
            pid->initialized = 0;
            break;
        }
        usart2_write_str("Invalid number. Try again.\r\n");
    }

    // UB
    while (1) {
        usart2_write_str("Temperature UB setpoint = ");
        uart_read_line_echo(line, sizeof(line));
        if (parse_float_line(line, &v)) {
            *p_ub = v;
            break;
        }
        usart2_write_str("Invalid number. Try again.\r\n");
    }

    // LB
    while (1) {
        usart2_write_str("Temperature LB setpoint = ");
        uart_read_line_echo(line, sizeof(line));
        if (parse_float_line(line, &v)) {
            *p_lb = v;
            break;
        }
        usart2_write_str("Invalid number. Try again.\r\n");
    }

    // Validate band
    if (!(*p_lb < *p_ub)) {
        usart2_write_str("ERROR: LB must be < UB. Re-enter config.\r\n");
        return;
    }

    usart2_write_str("\r\nSaved settings: ");
    print_settings(*p_target, *p_ub, *p_lb);
    usart2_write_str("Press 1 to resume streaming.\r\n");
}



// ======================================================
// MAIN
// ======================================================
int main(void)
{
    clock_init();
    systick_init(SYSCLK_FREQ_HZ);

    usart2_init(36000000UL, 115200);
    usart2_write_str("\r\nStart PID Test: TC + IR(object), heat-only with Vsense\r\n");

    delay_ms(200);

    tc_init();
    adc2_init_single(PELTIER_ADC_CH);
    i2c1_init(36000000U, 100000U);
    pwm_tim1_ch1_init(SYSCLK_FREQ_HZ, 2000U);

    // PID
    pid_t pid;
    const float dt_s = 0.02f;

    float targetC = 100.0f;
    float ubC     = 103.0f;
    float lbC     = 97.0f;

    const float out_min = 0.0f;
    const float out_max = 0.70f;

    const float Kp = 0.0203464726870566f;
    const float Ki = 0.0203600773423131f;
    const float Kd = 0.0f;

    pid_init(&pid, Kp, Ki, Kd, dt_s, out_min, out_max);

    print_menu();
    usart2_write_str("Current settings: ");
    print_settings(targetC, ubC, lbC);

    ui_mode_t ui = UI_STREAM;

    float duty = 0.0f;

    // watchdog printing setup for HALT/CONFIG idle periods
    tc_watchdog_t halt_wd = {0};
    halt_wd.ms_print = 250; // print TC every 250ms in HALT

    while (1)
    {
        // -------- Menu key handling (always active) --------
        char key;
        if (ui_poll_menu_key_nonblocking(&key)) {
            if (key == '1') {
                ui = UI_STREAM;
                usart2_write_str("\r\nStreaming ON (20ms)\r\n");
            } else if (key == '2') {
                ui = UI_CONFIG;
                usart2_write_str("\r\nEntering CONFIG (heating OFF)\r\n");
            } else if (key == '3') {
                ui = UI_HALT;
                usart2_write_str("\r\nHALT: heating OFF, TC monitoring continues\r\n");
            }
        }

        // -------- HALT MODE --------
        // Heating stays OFF, but we still read TC repeatedly.
        if (ui == UI_HALT) {
            pwm_tim1_set(0.0f);   // heating OFF
            duty = 0.0f;

            pid.integrator  = 0.0f;
            pid.initialized = 0;

            // Do nothing except wait for menu key
            delay_ms(20);
            continue;
        }


        // -------- CONFIG MODE --------
        // Stop PWM and run dialog; dialog itself keeps TC monitoring alive.
        if (ui == UI_CONFIG) {
            pwm_tim1_set(0.0f);
            duty = 0.0f;

            pid.integrator  = 0.0f;
            pid.initialized = 0;

            run_config_dialog(&targetC, &ubC, &lbC, &pid);

            // Stay stopped until user chooses
            while (1) {
                char k;
                if (ui_poll_menu_key_nonblocking(&k)) {
                    if (k == '1') {
                        ui = UI_STREAM;
                        usart2_write_str("\r\nStreaming ON\r\n");
                        break;
                    } else if (k == '3') {
                        ui = UI_HALT;
                        usart2_write_str("\r\nHALT\r\n");
                        break;
                    } else if (k == '2') {
                        run_config_dialog(&targetC, &ubC, &lbC, &pid);
                    }
                }
                delay_ms(20);
            }

            continue;
        }


        // -------- STREAM MODE (20ms sampling) --------

        // Read thermocouple (control sensor)
        int32_t t_x10 = tc_read_c_x10();
        float measC = (float)t_x10 * 0.1f;

        // Read IR sensor (object)
        int32_t ir_obj_mdeg = 0;
        int rc_obj = mlx90614_read_object(&ir_obj_mdeg);
        float ir_objC = 0.0f;
        if (rc_obj == 0) {
            ir_objC = (float)ir_obj_mdeg / 1000.0f;
        }

        // Vsense (optional)
        uint16_t raw_v = adc2_read_single(PELTIER_ADC_CH);
        float v_adc = (float)raw_v * (float)VREF_mV / 4095.0f / 1000.0f;
        (void)v_adc;

        // PID + safety logic
        int mode = 0;

        if (measC > ubC) {
            duty = 0.0f;
            mode = 2;
            pid.integrator  = 0.0f;
            pid.initialized = 0;
        } else {
            float u = pid_step(&pid, targetC, measC);
            duty = u;

            if (measC < lbC) mode = 0;
            else             mode = 1;
        }

        pwm_tim1_set(duty);

        // Telemetry
        usart2_write_str("TC=");
        print_float_1dp(measC);
        usart2_write_str("C | IR=");

        if (rc_obj == 0) {
            print_float_1dp(ir_objC);
        } else {
            usart2_write_str("ERR=");
            print_int(rc_obj);
        }

        usart2_write_str("C | duty=%");
        print_float_1dp(duty * 100.0f);

        usart2_write_str(" | Tgt=");
        print_float_1dp(targetC);
        usart2_write_str(" UB=");
        print_float_1dp(ubC);
        usart2_write_str(" LB=");
        print_float_1dp(lbC);

        usart2_write_str(" | state=");
        usart2_write_str(mode_to_str(mode));
        usart2_write_str("\r\n");

        // 20 ms loop
        delay_ms(20);
    }
}

#endif

#if (MAIN == 4)

#include <stdint.h>

#include "board.h"
#include "rcc.h"
#include "delay.h"
#include "usart.h"

#include "i2c.h"
#include "mlx90614.h"

static void uart_send_char(char c)
{
    usart2_write_char(c);
}

static void uart_send_str(const char *s)
{
    usart2_write_str(s);
}

static void uart_send_int(int32_t x)
{
    char buf[16];
    int idx = 0;

    if (x < 0) {
        uart_send_char('-');
        x = -x;
    }

    do {
        buf[idx++] = (char)('0' + (x % 10));
        x /= 10;
    } while (x > 0);

    while (idx--)
        uart_send_char(buf[idx]);
}

static void uart_send_temp_2dec(const char *label, int32_t mdeg)
{
    int32_t sign    = (mdeg < 0) ? -1 : 1;
    int32_t abs_val = (mdeg < 0) ? -mdeg : mdeg;

    int32_t whole = abs_val / 1000;
    int32_t centi = (abs_val % 1000) / 10;

    uart_send_str(label);
    uart_send_str(": ");

    if (sign < 0)
        uart_send_char('-');

    uart_send_int(whole);
    uart_send_char('.');
    if (centi < 10)
        uart_send_char('0');
    uart_send_int(centi);

    uart_send_str(" C\r\n");
}

int main(void)
{
    clock_init();
    systick_init(SYSCLK_FREQ_HZ);
    usart2_init(36000000U, 115200U);

    delay_ms(200);

    uart_send_str("\r\nMLX90614 IR TEMP TEST START\r\n");
    i2c1_init(36000000U, 100000U);

    uint32_t sample = 0;

    while (1)
    {
        int32_t obj, amb;
        int rc_obj, rc_amb;

        uart_send_str("\r\n--- Sample #");
        uart_send_int(sample++);
        uart_send_str(" ---\r\n");

        rc_obj = mlx90614_read_object(&obj);
        rc_amb = mlx90614_read_ambient(&amb);

        if (rc_obj == 0)
            uart_send_temp_2dec("IR Object Temp", obj);
        else {
            uart_send_str("IR Object Temp read error rc=");
            uart_send_int(rc_obj);
            uart_send_str("\r\n");
        }

        if (rc_amb == 0)
            uart_send_temp_2dec("IR Ambient Temp", amb);
        else {
            uart_send_str("IR Ambient Temp read error rc=");
            uart_send_int(rc_amb);
            uart_send_str("\r\n");
        }

        // 500 ms between samples
        delay_ms(500);
    }
}

#endif

#if (MAIN == 7)
#include <stdint.h>
#include "board.h"
#include "rcc.h"
#include "delay.h"
#include "usart.h"

#include "thermocouple.h"
#include "pwm.h"
#include "i2c.h"
#include "mlx90614.h"
#include "pid.h"

static void print_int(int v)
{
    char buf[16];
    int i = 15;
    buf[i] = '\0';
    int neg = (v < 0);
    if (neg) v = -v;

    do {
        buf[--i] = (char)('0' + (v % 10));
        v /= 10;
    } while (v);

    if (neg) buf[--i] = '-';
    usart2_write_str(&buf[i]);
}

static void print_float_1dp(float x)
{
    int32_t xi = (int32_t)x;
    int32_t xf = (int32_t)((x - (float)xi) * (x >= 0 ? 10.0f : -10.0f));

    if (x < 0 && xi == 0)
        usart2_write_char('-');

    print_int(xi);
    usart2_write_char('.');

    if (xf < 0) xf = -xf;
    print_int(xf);
}

static const char* mode_to_str(int mode)
{
    switch (mode) {
        case 0: return "HEATING_UP";
        case 1: return "IN_RANGE";
        case 2: return "STOPPED_OVER_TEMP_COOLING DOWN";
        default: return "UNKNOWN";
    }
}

int main(void)
{
    clock_init();                          // 72 MHz system clock
    systick_init(SYSCLK_FREQ_HZ);

    usart2_init(36000000UL, 115200);
    usart2_write_str("\r\nStart PID Test: IR (object) control, heat-only\r\n");

    // Small startup delay (gives sensors time to power up)
    delay_ms(200);

    // Thermocouple (ADC) - Still read for monitoring
    tc_init();

    // I2C + MLX90614
    i2c1_init(36000000U, 100000U);  // PCLK1 = 36 MHz, I2C at 100 kHz

    pwm_tim1_ch1_init(SYSCLK_FREQ_HZ, 2000U);   // 2 kHz PWM

    // PID setup
    pid_t pid;
    const float dt_s    = 0.02f;   // 20 ms loop
    const float setC    = 100.0f;  // target temperature in °C
    const float out_min = 0.0f;    // heat only, 0% duty
    const float out_max = 0.70f;   // 70% duty

    // Initial gains
//    const float Kp = 0.0886757f;
//    const float Ki = 0.0530638f;

    const float Kp = 0.0203464726870566f;
    const float Ki = 0.0203600773423131f;
    const float Kd = 0.0f;

    pid_init(&pid, Kp, Ki, Kd, dt_s, out_min, out_max);

    // Bounds for IR object temp control
    const float BAND_LO = 97.0f;
    const float BAND_HI = 103.0f;

    float duty = 0.0f;
    float current_control_temp = 0.0f; // Stores the temp used for control (IR temp if valid)

    while (1)
    {
        // Read thermocouple (for monitoring/debugging)
        int32_t t_x10 = tc_read_c_x10();
        float   measC = (float)t_x10 * 0.1f;

        // Read IR sensor
        int32_t ir_obj_mdeg = 0;
        int rc_obj = mlx90614_read_object(&ir_obj_mdeg);
        float ir_objC = 0.0f;
        int ir_valid = 0;

        if (rc_obj == 0)
        {
            ir_objC = (float)ir_obj_mdeg / 1000.0f;
            ir_valid = 1;
        }

        // --- PID + safety logic (Uses IR temp) ---
        int mode = 0;

        if (ir_valid)
        {
            current_control_temp = ir_objC;

            if (current_control_temp > BAND_HI)
            {
                // Above BAND_HI C → safety stop
                duty = 0.0f;
                mode = 2;

                pid.integrator  = 0.0f;
                pid.initialized = 0;
            }
            else
            {
                // Pass IR object temp to PID
                float u = pid_step(&pid, setC, current_control_temp);
                duty = u;

                if (current_control_temp < BAND_LO)
                    mode = 0;  // HEATING_UP
                else
                    mode = 1;  // IN_RANGE
            }
        }
        else
        {
            // IR reading failed, stop heating as a safety measure and reset PID
            duty = 0.0f;
            mode = 3; // UNKNOWN mode in this case - could be ERROR
            pid.integrator  = 0.0f;
            pid.initialized = 0;
        }


        // Apply PWM to peltier
        pwm_tim1_set(duty);

        // ---- Telemetry ----
        usart2_write_str("TC = ");
        print_float_1dp(measC);
        usart2_write_str(" C | IR = ");

        if (rc_obj == 0)
            print_float_1dp(ir_objC);
        else {
            usart2_write_str("ERR=");
            print_int(rc_obj);
        }

        usart2_write_str(" C | ControlTemp = ");
        print_float_1dp(current_control_temp);
        usart2_write_str(" C | duty = ");
        print_float_1dp(duty * 100.0f);
        usart2_write_str("% | state = ");
        usart2_write_str(mode_to_str(mode));
        usart2_write_str("\r\n");

        // PID loop period
        delay_ms(20);

        // delay_ms(15000);
    }
}
#endif

#if (MAIN == 8)
#include <stdint.h>
#include <math.h>
#include "board.h"
#include "rcc.h"
#include "delay.h"
#include "usart.h"

#include "thermocouple.h"
#include "pwm.h"
#include "i2c.h"
#include "mlx90614.h"
#include "pid.h"
#include "adc.h"

// ===================== Channel mapping (as requested) =====================
// ADC1: Thermocouples
#define ADC1_CH_TC1            0U      // PA0 / ADC1_IN0
#define ADC1_CH_TC2            1U      // PA1 / ADC1_IN1

// ADC2: Everything else
#define ADC2_CH_OPT_TIA        2U      // PA2 / ADC2_IN2   (TIA output => Vtia)
#define ADC2_CH_VSENSE         3U      // PA3 / ADC2_IN3   (Vsense)
#define ADC2_CH_ISENSE         4U      // PA4 / ADC2_IN4   (Isense voltage output)

// ===================== ADC / Photodiode conversion constants =====================
#define VREF_mV                3300U

#define PD_RESP_A_PER_W        0.53f       // Photodiode responsivity (A/W)
#define TIA_RF_OHMS            100000.0f   // TIA feedback resistor (ohms)
#define TIA_VBIAS_V            1.65f       // Output bias (V). Set to 0.0 if ground-referenced.
#define PD_USE_MAGNITUDE       1           // 1 = abs(current)

static void print_int(int v)
{
    char buf[16];
    int i = 15;
    buf[i] = '\0';
    int neg = (v < 0);
    if (neg) v = -v;

    do {
        buf[--i] = (char)('0' + (v % 10));
        v /= 10;
    } while (v);

    if (neg) buf[--i] = '-';
    usart2_write_str(&buf[i]);
}

static void print_float_1dp(float x)
{
    int32_t xi = (int32_t)x;
    int32_t xf = (int32_t)((x - (float)xi) * (x >= 0 ? 10.0f : -10.0f));

    if (x < 0 && xi == 0)
        usart2_write_char('-');

    print_int((int)xi);
    usart2_write_char('.');

    if (xf < 0) xf = -xf;
    if (xf < 10) usart2_write_char((char)('0' + xf));
    else print_int((int)xf);
}

static void print_u32(uint32_t v)
{
    char buf[16];
    int i = 15;
    buf[i] = '\0';
    do {
        buf[--i] = (char)('0' + (v % 10U));
        v /= 10U;
    } while (v);
    usart2_write_str(&buf[i]);
}

static const char* mode_to_str(int mode)
{
    switch (mode) {
        case 0: return "HEATING_UP";
        case 1: return "IN_RANGE";
        case 2: return "STOPPED_OVER_TEMP";
        default: return "UNKNOWN";
    }
}

// ===================== ADC conversion helpers =====================
static inline float adc12_to_volts(uint16_t raw)
{
    return ((float)raw * ((float)VREF_mV / 1000.0f)) / 4095.0f;
}

static inline float tia_volts_to_current_A(float v_out)
{
    float i = (v_out - TIA_VBIAS_V) / TIA_RF_OHMS;
#if PD_USE_MAGNITUDE
    if (i < 0.0f) i = -i;
#endif
    return i;
}

static inline float current_A_to_power_W(float i_A)
{
    return i_A / PD_RESP_A_PER_W;
}

int main(void)
{
    clock_init();
    systick_init(SYSCLK_FREQ_HZ);

    usart2_init(36000000UL, 115200);
    usart2_write_str("\r\nStart PID Test: 2x Thermocouples (ADC1) + Optical/Vsense/Isense (ADC2)\r\n");

    delay_ms(200);

    // ---- Thermocouples on ADC1 ----
    // tc_init() should init ADC1 and put both PA0/PA1 into analog mode + sample time.
    tc_init();

    // ---- ADC2 channels (PA2/PA3/PA4) ----
    // Initialize ADC2 and ensure all needed pins are configured for analog + sample time.
    adc2_init_single(ADC2_CH_VSENSE);

    // These helper calls are in the updated adc driver I suggested.
    // If you haven't added them yet, add them, or configure PA2/PA3/PA4 analog in adc2_init_single().
    adc2_enable_gpio_analog(ADC2_CH_OPT_TIA);
    adc2_enable_gpio_analog(ADC2_CH_VSENSE);
    adc2_enable_gpio_analog(ADC2_CH_ISENSE);

    adc2_set_sample_time_max(ADC2_CH_OPT_TIA);
    adc2_set_sample_time_max(ADC2_CH_VSENSE);
    adc2_set_sample_time_max(ADC2_CH_ISENSE);

    // ---- Other peripherals ----
    i2c1_init(36000000U, 100000U);
    pwm_tim1_ch1_init(SYSCLK_FREQ_HZ, 2000U);

    pid_t pid;
    const float dt_s    = 0.02f;

    const float SETPOINT_FINAL_C = 100.0f;
    const float out_min = 0.0f;
    const float out_max = 0.70f;

    const float Kp = 0.0203464726870566f;
    const float Ki = 0.0203600773423131f;
    const float Kd = 0.0f;

    pid_init(&pid, Kp, Ki, Kd, dt_s, out_min, out_max);

    const float BAND_LO = 97.0f;
    const float BAND_HI = 103.0f;

    float ramp_time_s    = 300.0f;
    float ramp_elapsed_s = 0.0f;
    float ramp_startC    = 25.0f;
    uint8_t ramp_started = 0;

    float duty = 0.0f;

    while (1)
    {
        // ---- Two thermocouples via ADC1 (AD8495 -> ADC) ----
        int32_t t1_x10 = tc_read_c_x10_ch(ADC1_CH_TC1);  // PA0
        int32_t t2_x10 = tc_read_c_x10_ch(ADC1_CH_TC2);  // PA1

        float measC1 = (float)t1_x10 * 0.1f;
        float measC2 = (float)t2_x10 * 0.1f;

        // Choose which thermocouple drives the PID control
        float measC = measC1;

        if (!ramp_started)
        {
            ramp_startC    = measC;
            ramp_elapsed_s = 0.0f;
            ramp_started   = 1;
            pid.integrator  = 0.0f;
            pid.initialized = 0;
        }

        ramp_elapsed_s += dt_s;

        float alpha = ramp_elapsed_s / ramp_time_s;
        if (alpha > 1.0f) alpha = 1.0f;
        float setC = ramp_startC + alpha * (SETPOINT_FINAL_C - ramp_startC);

        // ---- ADC2 reads ----
        // Optical power sensor (TIA output voltage)
        uint16_t raw_opt = adc2_read_single(ADC2_CH_OPT_TIA);
        float Vtia = adc12_to_volts(raw_opt);

        // Vsense
        uint16_t raw_vs = adc2_read_single(ADC2_CH_VSENSE);
        float Vsense = adc12_to_volts(raw_vs);

        // Isense (currently just the sensed voltage; convert to amps once you define shunt/gain)
        uint16_t raw_is = adc2_read_single(ADC2_CH_ISENSE);
        float Visense = adc12_to_volts(raw_is);

        // Photodiode current + optical power
        float Ipd_A  = tia_volts_to_current_A(Vtia);
        float Popt_W = current_A_to_power_W(Ipd_A);

        uint32_t Ipd_uA  = (uint32_t)(Ipd_A  * 1e6f + 0.5f);
        uint32_t Popt_uW = (uint32_t)(Popt_W * 1e6f + 0.5f);

        // ---- Safety: stop if EITHER thermocouple is above BAND_HI ----
        int mode = 0;
        if ((measC1 > BAND_HI) || (measC2 > BAND_HI))
        {
            duty = 0.0f;
            mode = 2;
            pid.integrator  = 0.0f;
            pid.initialized = 0;
        }
        else
        {
            float u = pid_step(&pid, setC, measC);
            duty = u;
            mode = (measC < BAND_LO) ? 0 : 1;
        }

        pwm_tim1_set(duty);

        // ---- Print ----
        usart2_write_str("TC1=");
        print_float_1dp(measC1);
        usart2_write_str("C | TC2=");
        print_float_1dp(measC2);
        usart2_write_str("C | SP=");
        print_float_1dp(setC);
        usart2_write_str("C | duty=");
        print_float_1dp(duty * 100.0f);
        usart2_write_str("%");

        usart2_write_str(" | Vtia=");
        print_float_1dp(Vtia);
        usart2_write_str("V");

        usart2_write_str(" | Vsense=");
        print_float_1dp(Vsense);
        usart2_write_str("V");

        usart2_write_str(" | Visense=");
        print_float_1dp(Visense);
        usart2_write_str("V");

        usart2_write_str(" | Ipd=");
        print_u32(Ipd_uA);
        usart2_write_str("uA");

        usart2_write_str(" | Popt=");
        print_u32(Popt_uW);
        usart2_write_str("uW");

        usart2_write_str(" | state=");
        usart2_write_str(mode_to_str(mode));

        usart2_write_str(" | ramp=");
        print_float_1dp(ramp_elapsed_s);
        usart2_write_str("/");
        print_float_1dp(ramp_time_s);
        usart2_write_str("s\r\n");

        delay_ms(20);
    }
}

#endif

#if (MAIN == MENU_N_8)
#include <stdint.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>   // strtof
#include <math.h>

#include "board.h"
#include "rcc.h"
#include "delay.h"
#include "usart.h"

#include "thermocouple.h"
#include "pwm.h"
#include "i2c.h"
#include "mlx90614.h"
#include "pid.h"
#include "adc.h"

// ===================== Channel mapping (as requested) =====================
// ADC1: Thermocouples
#define ADC1_CH_TC1            0U      // PA0 / ADC1_IN0
#define ADC1_CH_TC2            1U      // PA1 / ADC1_IN1

// ADC2: Everything else
#define ADC2_CH_OPT_TIA        4U      // PA4 / ADC2_IN4
#define ADC2_CH_VSENSE         5U      // PA5 / ADC2_IN5
#define ADC2_CH_ISENSE         6U      // PA6 / ADC2_IN6

// ===================== ADC / Photodiode conversion constants =====================
#define VREF_mV                3300U

#define PD_RESP_A_PER_W        0.53f       // Photodiode responsivity (A/W)
#define TIA_RF_OHMS            100000.0f   // TIA feedback resistor (ohms)
#define TIA_VBIAS_V            1.65f       // Output bias (V). Set to 0.0 if ground-referenced.
#define PD_USE_MAGNITUDE       1           // 1 = abs(current)

// ----------------- UART print helpers -----------------
static void print_int(int v)
{
    char buf[16];
    int i = 15;
    buf[i] = '\0';
    int neg = (v < 0);
    if (neg) v = -v;

    do {
        buf[--i] = (char)('0' + (v % 10));
        v /= 10;
    } while (v);

    if (neg) buf[--i] = '-';
    usart2_write_str(&buf[i]);
}

static void print_u32(uint32_t v)
{
    char buf[16];
    int i = 15;
    buf[i] = '\0';
    do {
        buf[--i] = (char)('0' + (v % 10U));
        v /= 10U;
    } while (v);
    usart2_write_str(&buf[i]);
}

static void print_float_1dp(float x)
{
    int32_t xi = (int32_t)x;
    float frac = x - (float)xi;
    if (x < 0 && frac != 0) frac = -frac;

    int32_t xf = (int32_t)(frac * 10.0f + (x >= 0 ? 0.5f : -0.5f));

    if (x < 0 && xi == 0) usart2_write_char('-');
    print_int((int)xi);
    usart2_write_char('.');
    if (xf < 0) xf = -xf;
    usart2_write_char((char)('0' + (xf % 10)));
}

typedef enum {
    UI_STREAM = 0,
    UI_CONFIG = 1,
    UI_HALT   = 2
} ui_mode_t;

static const char* ui_mode_to_str(ui_mode_t m)
{
    switch (m) {
        case UI_STREAM: return "STREAM";
        case UI_CONFIG: return "CONFIG";
        case UI_HALT:   return "HALT";
        default:        return "UNKNOWN";
    }
}

static const char* heat_state_to_str(int state)
{
    switch (state) {
        case 0: return "HEATING_UP";
        case 1: return "IN_RANGE";
        case 2: return "STOPPED_OVER_TEMP";
        default:return "UNKNOWN";
    }
}

// ===================== ADC conversion helpers =====================
static inline float adc12_to_volts(uint16_t raw)
{
    return ((float)raw * ((float)VREF_mV / 1000.0f)) / 4095.0f;
}

static inline float tia_volts_to_current_A(float v_out)
{
    float i = (v_out - TIA_VBIAS_V) / TIA_RF_OHMS;
#if PD_USE_MAGNITUDE
    if (i < 0.0f) i = -i;
#endif
    return i;
}

static inline float current_A_to_power_W(float i_A)
{
    return i_A / PD_RESP_A_PER_W;
}

// ======================================================
// UART RX helpers (nonblocking key + blocking line w/ echo)
// ======================================================
static int usart2_try_read_char(char *out)
{
#if defined(USART2)
    if (USART2->SR & (1U << 5)) {          // RXNE
        *out = (char)(USART2->DR & 0xFF);  // read clears RXNE
        return 1;
    }
    return 0;
#else
    (void)out;
    return 0;
#endif
}

static void uart_read_line_echo(char *buf, uint32_t buf_sz)
{
    uint32_t len = 0;
    while (1) {
        char c;
        while (!usart2_try_read_char(&c)) { /* block */ }

        if (c == '\r' || c == '\n') {
            usart2_write_str("\r\n");
            break;
        }
        if (c == '\b' || c == 127) {
            if (len > 0) {
                len--;
                usart2_write_str("\b \b");
            }
            continue;
        }
        if ((unsigned char)c < 32) continue;

        if (len < (buf_sz - 1)) {
            buf[len++] = c;
            usart2_write_char(c); // echo
        }
    }
    buf[len] = '\0';
}

static int parse_float_line(const char *s, float *out)
{
    while (*s && isspace((unsigned char)*s)) s++;
    if (*s == '\0') return 0;

    char *endp = NULL;
    float v = strtof(s, &endp);
    if (endp == s) return 0;

    while (*endp && isspace((unsigned char)*endp)) endp++;
    if (*endp != '\0') return 0;

    *out = v;
    return 1;
}

// Read menu keys without blocking; echoes the key
static int ui_poll_menu_key_nonblocking(char *key_out)
{
    char c;
    if (!usart2_try_read_char(&c)) return 0;

    usart2_write_char(c);
    if (c == '\r' || c == '\n') usart2_write_str("\r\n");

    *key_out = c;
    return 1;
}

static void print_menu(void)
{
    usart2_write_str("\r\n=== MENU ===\r\n");
    usart2_write_str("1) Start/Resume RUN (20ms stream)\r\n");
    usart2_write_str("2) CONFIG: stop heating + change setpoints/ramp\r\n");
    usart2_write_str("3) HALT: heating OFF (pause ramp) \r\n");
    usart2_write_str("m) Print menu\r\n");
    usart2_write_str("s) Print current settings\r\n");
    usart2_write_str("============\r\n");
}

static void print_settings(float target_final, float ub, float lb, float ramp_time_s)
{
    usart2_write_str("TargetFinal=");
    print_float_1dp(target_final);
    usart2_write_str("C  UB=");
    print_float_1dp(ub);
    usart2_write_str("C  LB=");
    print_float_1dp(lb);
    usart2_write_str("C  RampTime=");
    print_float_1dp(ramp_time_s);
    usart2_write_str("s\r\n");
}

static void run_config_dialog(float *p_target_final,
                              float *p_ub,
                              float *p_lb,
                              float *p_ramp_time_s,
                              pid_t *pid,
                              uint8_t *p_ramp_started,
                              float *p_ramp_elapsed_s)
{
    char line[64];
    float v;

    usart2_write_str("\r\n--- CONFIG MODE ---\r\n");
    usart2_write_str("Heating OFF. Enter values in degC (ramp in seconds).\r\n");

    // Target Final
    while (1) {
        usart2_write_str("Temperature Target FINAL setpoint = ");
        uart_read_line_echo(line, sizeof(line));
        if (parse_float_line(line, &v)) {
            *p_target_final = v;
            pid->integrator  = 0.0f;
            pid->initialized = 0;
            break;
        }
        usart2_write_str("Invalid number. Try again.\r\n");
    }

    // UB
    while (1) {
        usart2_write_str("Temperature UB setpoint = ");
        uart_read_line_echo(line, sizeof(line));
        if (parse_float_line(line, &v)) {
            *p_ub = v;
            break;
        }
        usart2_write_str("Invalid number. Try again.\r\n");
    }

    // LB
    while (1) {
        usart2_write_str("Temperature LB setpoint = ");
        uart_read_line_echo(line, sizeof(line));
        if (parse_float_line(line, &v)) {
            *p_lb = v;
            break;
        }
        usart2_write_str("Invalid number. Try again.\r\n");
    }

    // Ramp time
    while (1) {
        usart2_write_str("Ramp time (seconds) = ");
        uart_read_line_echo(line, sizeof(line));
        if (parse_float_line(line, &v) && v > 0.0f) {
            *p_ramp_time_s = v;
            break;
        }
        usart2_write_str("Invalid number (must be > 0). Try again.\r\n");
    }

    if (!(*p_lb < *p_ub)) {
        usart2_write_str("ERROR: LB must be < UB. Re-enter config.\r\n");
        return;
    }

    // Restart ramp from current temperature when resuming
    *p_ramp_started   = 0;
    *p_ramp_elapsed_s = 0.0f;

    usart2_write_str("\r\nSaved settings: ");
    print_settings(*p_target_final, *p_ub, *p_lb, *p_ramp_time_s);
    usart2_write_str("Press 1 to resume RUN.\r\n");
}

int main(void)
{
    clock_init();
    systick_init(SYSCLK_FREQ_HZ);

    usart2_init(36000000UL, 115200);
    usart2_write_str("\r\nStart PI Test + Menu: 2x Thermocouples (ADC1) + Optical/Vsense/Isense (ADC2)\r\n");

    delay_ms(200);

    // ---- Thermocouples on ADC1 ----
    // Requires your updated thermocouple module to expose tc_read_c_x10_ch()
    tc_init();

    // ---- ADC2 init + enable channels on PA2/PA3/PA4 ----
    adc2_init_single(ADC2_CH_VSENSE);
    adc2_enable_gpio_analog(ADC2_CH_OPT_TIA);
    adc2_enable_gpio_analog(ADC2_CH_VSENSE);
    adc2_enable_gpio_analog(ADC2_CH_ISENSE);

    adc2_set_sample_time_max(ADC2_CH_OPT_TIA);
    adc2_set_sample_time_max(ADC2_CH_VSENSE);
    adc2_set_sample_time_max(ADC2_CH_ISENSE);

    // ---- Other peripherals ----
    i2c1_init(36000000U, 100000U);
    pwm_tim1_ch1_init(SYSCLK_FREQ_HZ, 2000U);

    // PID
    pid_t pid;
    const float dt_s = 0.02f;

    // Settings (modifiable via menu)
    float target_finalC = 100.0f;
    float ubC           = 103.0f;
    float lbC           = 97.0f;
    float ramp_time_s   = 300.0f;

    const float out_min = 0.0f;
    const float out_max = 0.70f;

    const float Kp = 0.0203464726870566f;
    const float Ki = 0.0203600773423131f;
    const float Kd = 0.0f;

    pid_init(&pid, Kp, Ki, Kd, dt_s, out_min, out_max);

    // Ramp state
    float   ramp_elapsed_s = 0.0f;
    float   ramp_startC    = 25.0f;
    uint8_t ramp_started   = 0;

    ui_mode_t ui = UI_STREAM;

    print_menu();
    usart2_write_str("Current settings: ");
    print_settings(target_finalC, ubC, lbC, ramp_time_s);

    float duty = 0.0f;

    // For HALT/CONFIG periodic monitoring prints
    uint32_t idle_print_ms_accum = 0;

    while (1)
    {
        char key;
        if (ui_poll_menu_key_nonblocking(&key)) {
            if (key == '1') {
                ui = UI_STREAM;
                usart2_write_str("\r\nRUN: streaming ON (20ms). Ramp resumes.\r\n");
            } else if (key == '2') {
                ui = UI_CONFIG;
                usart2_write_str("\r\nEntering CONFIG (heating OFF, ramp paused)\r\n");
            } else if (key == '3') {
                ui = UI_HALT;
                usart2_write_str("\r\nHALT: heating OFF, ramp paused\r\n");
            } else if (key == 'm' || key == 'M') {
                print_menu();
            } else if (key == 's' || key == 'S') {
                usart2_write_str("Settings: ");
                print_settings(target_finalC, ubC, lbC, ramp_time_s);
            }
        }

        // -------- Always read thermocouples (for safety + UI) --------
        int32_t t1_x10 = tc_read_c_x10_ch(ADC1_CH_TC1);
        int32_t t2_x10 = tc_read_c_x10_ch(ADC1_CH_TC2);

        float measC1 = (float)t1_x10 * 0.1f;
        float measC2 = (float)t2_x10 * 0.1f;

        // Choose which TC drives PID (TC1)
        float measC = measC1;

        // -------- HALT MODE --------
        if (ui == UI_HALT) {
            pwm_tim1_set(0.0f);
            duty = 0.0f;

            pid.integrator  = 0.0f;
            pid.initialized = 0;

            // Optional: print monitoring line every 250ms
            idle_print_ms_accum += 20;
            if (idle_print_ms_accum >= 250) {
                idle_print_ms_accum = 0;

                usart2_write_str("[HALT] TC1=");
                print_float_1dp(measC1);
                usart2_write_str("C TC2=");
                print_float_1dp(measC2);
                usart2_write_str("C (UB=");
                print_float_1dp(ubC);
                usart2_write_str("C)\r\n");
            }

            delay_ms(20);
            continue;
        }

        // -------- CONFIG MODE --------
        if (ui == UI_CONFIG) {
            pwm_tim1_set(0.0f);
            duty = 0.0f;

            pid.integrator  = 0.0f;
            pid.initialized = 0;

            run_config_dialog(&target_finalC, &ubC, &lbC, &ramp_time_s,
                              &pid, &ramp_started, &ramp_elapsed_s);

            // Stay stopped until user chooses 1 (or halt)
            while (1) {
                char k;
                if (ui_poll_menu_key_nonblocking(&k)) {
                    if (k == '1') {
                        ui = UI_STREAM;
                        usart2_write_str("\r\nRUN\r\n");
                        break;
                    } else if (k == '3') {
                        ui = UI_HALT;
                        usart2_write_str("\r\nHALT\r\n");
                        break;
                    } else if (k == '2') {
                        run_config_dialog(&target_finalC, &ubC, &lbC, &ramp_time_s,
                                          &pid, &ramp_started, &ramp_elapsed_s);
                    } else if (k == 'm' || k == 'M') {
                        print_menu();
                    } else if (k == 's' || k == 'S') {
                        usart2_write_str("Settings: ");
                        print_settings(target_finalC, ubC, lbC, ramp_time_s);
                    }
                }

                // minimal monitoring line every 250ms
                idle_print_ms_accum += 20;
                if (idle_print_ms_accum >= 250) {
                    idle_print_ms_accum = 0;

                    // re-read TC quickly for current view
                    int32_t tt1_x10 = tc_read_c_x10_ch(ADC1_CH_TC1);
                    int32_t tt2_x10 = tc_read_c_x10_ch(ADC1_CH_TC2);
                    float m1 = (float)tt1_x10 * 0.1f;
                    float m2 = (float)tt2_x10 * 0.1f;

                    usart2_write_str("[CFG] TC1=");
                    print_float_1dp(m1);
                    usart2_write_str("C TC2=");
                    print_float_1dp(m2);
                    usart2_write_str("C\r\n");
                }

                delay_ms(20);
            }

            continue;
        }

        // -------- STREAM MODE (20ms loop) --------
        idle_print_ms_accum = 0;

        // Start ramp from current temp when entering RUN after config (or first time)
        if (!ramp_started) {
            ramp_startC    = measC;     // TC1 as ramp reference
            ramp_elapsed_s = 0.0f;
            ramp_started   = 1;
            pid.integrator  = 0.0f;
            pid.initialized = 0;
        }

        // Ramp progresses only in STREAM mode
        ramp_elapsed_s += dt_s;
        float alpha = ramp_elapsed_s / ramp_time_s;
        if (alpha > 1.0f) alpha = 1.0f;

        float setC = ramp_startC + alpha * (target_finalC - ramp_startC);

        // ---- ADC2 reads ----
        uint16_t raw_opt = adc2_read_single(ADC2_CH_OPT_TIA);
        float Vtia = adc12_to_volts(raw_opt);

        uint16_t raw_vs = adc2_read_single(ADC2_CH_VSENSE);
        float Vsense = adc12_to_volts(raw_vs);

        uint16_t raw_is = adc2_read_single(ADC2_CH_ISENSE);
        float Visense = adc12_to_volts(raw_is);

        float Ipd_A  = tia_volts_to_current_A(Vtia);
        float Popt_W = current_A_to_power_W(Ipd_A);

        uint32_t Ipd_uA  = (uint32_t)(Ipd_A  * 1e6f + 0.5f);
        uint32_t Popt_uW = (uint32_t)(Popt_W * 1e6f + 0.5f);

        // ---- Safety: stop if EITHER thermocouple exceeds UB ----
        int heat_state = 0;

        if (measC1 > ubC) {
            duty = 0.0f;
            heat_state = 2;
            pid.integrator  = 0.0f;
            pid.initialized = 0;
        } else {
            float u = pid_step(&pid, setC, measC); // measC == measC1
            duty = u;
            heat_state = (measC1 < lbC) ? 0 : 1;
        }


        pwm_tim1_set(duty);

        // ---- Telemetry ----
        usart2_write_str("TC1=");
        print_float_1dp(measC1);
        usart2_write_str("C | TC2=");
        print_float_1dp(measC2);
        usart2_write_str("C | SP=");
        print_float_1dp(setC);
        usart2_write_str("C | duty=");
        print_float_1dp(duty * 100.0f);
        usart2_write_str("%");

//        usart2_write_str(" | Vsense=");
//        print_float_1dp(Vsense);
//        usart2_write_str("V");

//        usart2_write_str(" | Vtia=");
//        print_float_1dp(Vtia);
//        usart2_write_str("V");

//        usart2_write_str(" | Ipd=");
//        print_u32(Ipd_uA);
//        usart2_write_str("uA");

//        usart2_write_str(" | Popt=");
//        print_u32(Popt_uW);
//        usart2_write_str("uW");

//        usart2_write_str(" | Visense=");
//        print_float_1dp(Visense);
//        usart2_write_str("V");

        usart2_write_str(" | state=");
        usart2_write_str(heat_state_to_str(heat_state));

//        usart2_write_str(" | ui=");
//        usart2_write_str(ui_mode_to_str(ui));

        usart2_write_str(" | ramp=");
        print_float_1dp(ramp_elapsed_s);
        usart2_write_str("/");
        print_float_1dp(ramp_time_s);
        usart2_write_str("s\r\n");

        delay_ms(200);
    }
}

#endif


#if (MAIN == BANG_LOOP)

/*
 * main.c  (Bang/Bang control version - heat only)
 *
 * - Uses MLX90614 IR object temperature as the control measurement
 * - Thermocouple is still read for monitoring/telemetry
 * - Bang/Bang with hysteresis latch:
 *      if T <= setC - HYST_C  => duty = out_max (heater ON)
 *      if T >= setC + HYST_C  => duty = out_min (heater OFF)
 *      else                   => keep last duty
 *
 * Safety:
 *  - If IR invalid => duty=0 and reset controller latch
 *  - If T > BAND_HI => duty=0 and reset controller latch
 */

#include <stdint.h>
#include "board.h"
#include "rcc.h"
#include "delay.h"
#include "usart.h"

#include "thermocouple.h"
#include "pwm.h"
#include "i2c.h"
#include "mlx90614.h"

// ---------- Bang/Bang controller (self-contained) ----------
typedef struct {
    float out_min;
    float out_max;
    float hyst_C;        // +/- hysteresis around setpoint (degC)
    float u;             // latched output
    uint8_t initialized; // latch init
} bangbang_t;

static inline float clampf(float x, float lo, float hi)
{
    if (x < lo) return lo;
    if (x > hi) return hi;
    return x;
}

static void bangbang_init(bangbang_t *bb, float hyst_C, float out_min, float out_max)
{
    bb->hyst_C = (hyst_C < 0.0f) ? -hyst_C : hyst_C;

    if (out_min <= out_max) {
        bb->out_min = out_min;
        bb->out_max = out_max;
    } else {
        bb->out_min = out_max;
        bb->out_max = out_min;
    }

    bb->u = bb->out_min;
    bb->initialized = 0;
}

static float bangbang_step_heatonly(bangbang_t *bb, float setpoint, float measurement)
{
    if (!bb->initialized) {
        bb->u = bb->out_min;
        bb->initialized = 1;
    }

    float on_thresh  = setpoint - bb->hyst_C;
    float off_thresh = setpoint + bb->hyst_C;

    if (measurement <= on_thresh) {
        bb->u = bb->out_max;     // ON
    } else if (measurement >= off_thresh) {
        bb->u = bb->out_min;     // OFF
    } // else: hold last bb->u (hysteresis band)

    return clampf(bb->u, bb->out_min, bb->out_max);
}
// -----------------------------------------------------------

static void print_int(int v)
{
    char buf[16];
    int i = 15;
    buf[i] = '\0';
    int neg = (v < 0);
    if (neg) v = -v;

    do {
        buf[--i] = (char)('0' + (v % 10));
        v /= 10;
    } while (v);

    if (neg) buf[--i] = '-';
    usart2_write_str(&buf[i]);
}

static void print_float_1dp(float x)
{
    int32_t xi = (int32_t)x;
    int32_t xf = (int32_t)((x - (float)xi) * (x >= 0 ? 10.0f : -10.0f));

    if (x < 0 && xi == 0)
        usart2_write_char('-');

    print_int(xi);
    usart2_write_char('.');

    if (xf < 0) xf = -xf;
    print_int(xf);
}

static const char* mode_to_str(int mode)
{
    switch (mode) {
        case 0: return "HEATING_ON";
        case 1: return "IN_HYST_BAND_HOLD";
        case 2: return "SAFETY_OFF_OVER_TEMP";
        case 3: return "SAFETY_OFF_IR_FAIL";
        default: return "UNKNOWN";
    }
}

int main(void)
{
    clock_init();                          // 72 MHz system clock
    systick_init(SYSCLK_FREQ_HZ);

    usart2_init(36000000UL, 115200);
    usart2_write_str("\r\nStart Bang/Bang Test: IR (object) control, heat-only\r\n");

    // Small startup delay (gives sensors time to power up)
    delay_ms(200);

    // Thermocouple (ADC) - Still read for monitoring
    tc_init();

    // I2C + MLX90614
    i2c1_init(36000000U, 100000U);  // PCLK1 = 36 MHz, I2C at 100 kHz

    // PWM (duty 0..1 expected by pwm_tim1_set in your codebase)
    pwm_tim1_ch1_init(SYSCLK_FREQ_HZ, 2000U);   // 2 kHz PWM

    // -------- Bang/Bang settings --------
    bangbang_t bb;

    const float setC    = 100.0f;  // target temp (°C)
    const float out_min = 0.0f;    // 0% duty
    const float out_max = 0.70f;   // 70% duty (heater ON level)

    // Hysteresis band size (tune this!)
    // ON when T <= setC - HYST_C, OFF when T >= setC + HYST_C
    const float HYST_C  = 1.0f;    // +/- 1°C hysteresis

    bangbang_init(&bb, HYST_C, out_min, out_max);

    // Safety bounds for IR object temp control
    const float BAND_HI = 103.0f;  // hard safety cutoff (°C)
    // -----------------------------------

    float duty = 0.0f;
    float current_control_temp = 0.0f; // IR temp if valid, else last/0

    while (1)
    {
        // Read thermocouple (for monitoring/debugging)
        int32_t t_x10 = tc_read_c_x10();
        float   measC = (float)t_x10 * 0.1f;

        // Read IR sensor
        int32_t ir_obj_mdeg = 0;
        int rc_obj = mlx90614_read_object(&ir_obj_mdeg);

        float ir_objC = 0.0f;
        int   ir_valid = 0;

        if (rc_obj == 0) {
            ir_objC = (float)ir_obj_mdeg / 1000.0f;
            ir_valid = 1;
        }

        int mode = 0;

        if (ir_valid)
        {
            current_control_temp = ir_objC;

            // Safety cutoff
            if (current_control_temp > BAND_HI)
            {
                duty = 0.0f;
                mode = 2;

                // reset latch so it doesn't "remember ON" when you come back
                bb.u = 0.0f;
                bb.initialized = 0;
            }
            else
            {
                // Bang/Bang decision (heat-only)
                duty = bangbang_step_heatonly(&bb, setC, current_control_temp);

                // State labeling (optional, for telemetry readability)
                if (current_control_temp <= (setC - HYST_C))
                    mode = 0;  // HEATING_ON
                else if (current_control_temp >= (setC + HYST_C))
                    mode = 2;  // OFF region (not necessarily safety, but "forced OFF")
                else
                    mode = 1;  // IN_HYST_BAND_HOLD
            }
        }
        else
        {
            // IR reading failed => safety OFF
            duty = 0.0f;
            mode = 3;

            bb.u = 0.0f;
            bb.initialized = 0;
        }

        // Apply PWM
        pwm_tim1_set(duty);

        // ---- Telemetry ----
        usart2_write_str("TC = ");
        print_float_1dp(measC);
        usart2_write_str(" C | IR = ");

        if (rc_obj == 0)
            print_float_1dp(ir_objC);
        else {
            usart2_write_str("ERR=");
            print_int(rc_obj);
        }

        usart2_write_str(" C | ControlTemp = ");
        print_float_1dp(current_control_temp);

        usart2_write_str(" C | duty = ");
        print_float_1dp(duty * 100.0f);
        usart2_write_str("% | state = ");
        usart2_write_str(mode_to_str(mode));
        usart2_write_str("\r\n");

        // Loop period ~20 ms (matches your old dt_s)
        delay_ms(20);
    }
}


#endif
